В **этом модуле вы разработаете книжный магазин на Next.js и Redux Toolkit.**

Проект будет использовать API от Google Books, который позволяет искать информацию о разных книгах и узнавать их цену в магазине Google Play. Для получения списка книг вам не потребуется использовать ключ.

В проекте будет много интерактивных элементов: слайдер на главной странице, авторизация, корзина и фильтры по книгам.

## **В ТЕЧЕНИЕ МОДУЛЯ ВЫ:**

1. Создадите мультистраничное приложение с помощью файлового роутинга;
2. Научитесь пользоваться статической генерацией для оптимизации загрузки страницы с помощью метода `getStaticProps`;
3. Изучите особенности использования Redux с Next.js, научитесь сохранять хранилище в `localStorage` с помощью Redux Persist;
4. Научитесь пользоваться папкой /api для создания своего небольшого API;
5. Научитесь оптимизировать приложение для поисковиков и пользоваться Chrome Lighthouse для оценки оптимизации.

Макет книжного магазина основан на [предыдущем проекте](https://apps.skillfactory.ru/learning/course/course-v1:SkillFactory+FRPRO+2022/block-v1:SkillFactory+FRPRO+2022+type@sequential+block@3a665d85ae35490c8a126319c36e22ae/block-v1:SkillFactory+FRPRO+2022+type@vertical+block@b1c99232989a4d24ade6617aa3fb2861), который вы сделали на стандартном JavaScript. Но в этот раз вы будете использовать другие технологии. Кроме того, в новом приложении будет расширенный функционал.

Для того, чтобы начать работу с проектом на Next.js, перейдите в папку с вашими проектами и запустите следующую команду:

```html
        npx create-next-app@latest
```

Эта команда создаст Next.js проект. В процессе установки необходимо будет ответить на несколько вопросов в командной строке:

```html
    1. Название проекта:
    ? What is your project named? <имя проекта>

    2. Хотите ли вы использовать TypeScript в вашем проекте?
    ?  Would you like **to** use TypeScript **with** this project?
    
    3. Хотите ли вы использовать линтер ESLint с предустановленным пресетом для **Next**.js?
    ?  Would you like **to** use ESLint **with** this project?
    
    4. Хотите ли вы использовать css-фреймворк Tailwind CSS?
    ? Would you like **to** use Tailwind CSS **with** this project?
    
    5. Хотите ли вы хранить ваш код в папке src вместо корневой папки?
    ? Would you like **to** use `src/` directory **with** this project?
    
    6. Если вы устанавливаете последнюю версию **Next**.js, то вам могут предложить использовать 
    экспериментальную директорию app/ (пока что отказываемся!)
    ? Would you like **to** use experimental `app/` directory **with** this project?
    
    7. Какой **alias** для импортов вы хотите использовать? (по умолчанию "@/"
     ? What import **alias** would you like configured?
```

В шестом пункте желательно отказаться от использования экспериментальной папки /app. На данный момент она находится в разработке и может работать нестабильно. Однако в будущих версиях Next.js эта папка позволит использовать серверные компоненты, а также объединять страницы приложений в отдельные группы. Эти группы могут использовать специальные компоненты в качестве заглушек при загрузке или появлении ошибки.

**Серверный компонент** — React-компонент, который позволяет рендерить свою разметку на сервере перед загрузкой страницы.

Использование серверных компонентов похоже на использование методов `getStaticProps` или `getServerSideProps`. Однако оно позволяет нам загружать на сервер не только данные, но и целые React-компоненты.

Так как серверные компоненты не могут использовать хуки React, (например, `useState` и `useEffect`), работа с ними может быть затруднена. Однако они крайне полезны, если нам необходимо выполнить запрос к API или сразу получить доступ к базе данных.

После выполнения команды `create-next-app` утилита создаст пустой проект и следующие файлы и папки:

В папке pages работает файловый роутинг. Также в ней каждая папка и файл отвечают за отдельный адрес в нашем приложении.

Например, если мы хотим создать дополнительную страницу со списком книг, то можем выбрать один из вариантов:

- Создать папку books и в ней файл index.tsx;
- Создать файл books.tsx в папке pages.
- 
*Пример файлового роутинга в приложении.*

Также в этой папке есть два файла — **_app.tsx** и **_document.tsx**.

**_app.tsx** является аналогом файла App.tsx в классическом React-приложении. Чаще всего он включает в себя все необходимые для приложения провайдеры.

**_document.tsx** — файл, который содержит в себе основные теги HTML-файла: `html`, `head`, `body`, `script` и т.д.

После того, как мы познакомились с пустым проектом, можем приступать к выполнению первой части задания. Вам остаётся выбрать решение для стилизации вашего приложения.

### **Полезные ссылки:**

- [Начало работы с Next.js](https://nextjs.org/docs/getting-started)
- [Сравнение Client Components и Server Components](https://beta.nextjs.org/docs/rendering/server-and-client-components)
- [Подробно о том, как работают React Server Components / Хабр](https://habr.com/ru/companies/kts/articles/653283/)    

## **ЗАДАНИЕ**

Вам необходимо сверстать главную страницу из макета. Используйте файл pages/index.tsx как главную страницу. Не забывайте делить вёрстку на компоненты.

[Макет в Figma](https://www.figma.com/file/mDoQo4SixsUM8iAgp5uDdC/bookshop?node-id=0%3A1&t=1cfodlGyrmXOuq8z-1)

Также создайте компонент Layout в любой папке, который затем будет подключен в файле _app.tsx. Этот компонент будет включать в себя шапку страницы с навигацией, поиском и названием сайта.

Ещё необходимо добавить интерактивность для слайдера на главной странице. Вы можете использовать стороннюю библиотеку вроде Swiper.js. Или можете написать собственное решение с нуля. За это вы получите больше баллов. :)

Для стилизации вы можете использовать любое решение — css-modules, препроцессоры, styled-components или Tailwind CSS.

**Для выполнения задания необходимо:**

- Перенести вёрстку слайдера в начале страницы без функционала;
- Перенести вёрстку списка книг и фильтры сбоку (можете использовать фейковые данные);
- Создать компонент Layout и перенести вёрстку шапки;
- Добавить интерактивность слайдеру. Интерактивность включает в себя возможность перелистывать слайды с помощью кнопок снизу, автоматическое перелистывание каждые 3-5 секунд и возвращение к первому слайду в конце.

Кроме главной страницы, новый проект включает в себя ещё две дополнительные страницы: профиль и корзину.

В Next.js не требуется установка дополнительных библиотек для роутинга. Навигация осуществляется с помощью компонента Link:

```html
        **import** **Link** **from** 'next/link';

        **function** **Home**() {
            **return** (
                <**Link** href="/books">Книги</**Link**>
        )}
```

Синтаксис полностью соответствует тегу `a`, который используется в HTML-разметке. Однако бывают случаи, когда навигацию по страницам нужно осуществлять с помощью программной навигации.

**Программная навигация** — навигация с помощью маршрутизатора путём прямого вызова методов.

Для программной навигации можно воспользоваться хуком `useRouter`.

```html
        **import** { useRouter } **from** 'next/router';

        **function** **Home**() {
            **const** router = **useRouter**();
            **const** **onClick** = () => router.**push**('/books');
        }
```

В целом это всё, что необходимо знать о навигации в Next.js проекте. Этих знаний достаточно, чтобы выполнить следующее задание.

## **ЗАДАНИЕ**

Вам необходимо перенести вёрстку двух страниц — корзины и профиля, а также добавить навигацию по приложению с помощью компонента Link. Новые страницы также должны использовать компонент Layout с шапкой.

Для статической генерации контента вы можете использовать метод `getStaticProps`. Используйте этот метод для данных, которые редко меняются.

```html
        'Component.tsx'

        **export** **async** **function** **getStaticProps**() {
            **const** res = **await** **fetch**('https://...');
        
            **const** receivedData = **await** res.**json**();
        
            **return** {
                props: {
                    data: receivedData,
                }
            }
        }
        
        **export** **default** **function** **Component**({ data }) {
            ...
        }
```

Метод обязательно должен возвращать объект с полем `props`. Иначе компилятор выдаст ошибку.

Мы можем использовать метод, чтобы получить данные из API Google Books. Но перед этим давайте рассмотрим функционал API Routes.

Как вы заметили, в пустом проекте присутствует папка api/. Эта папка позволяет нам создавать сервис, схожий функционалом со стандартным бэкендом. Эта папка полезна при написании Backend For Frontend.

**Backend For Frontend (сокр. BFF или B4F)** — как правило, небольшой слой приложения между фронтендом и бэкендом, который позволяет предварительно обрабатывать приходящие или исходящие данные.

Рассмотрим пример с API Google Books. Чтобы получить постраничный список книг по определенной теме, необходимо отправить GET-запрос на следующий адрес:

`https://www.googleapis.com/books/v1/volumes?q=**Subject**:<тема>&pageIndex=0&maxResults=6`

**В запросе у нас есть как минимум 3 параметра:**

- `q` или `query` — само тело запроса;
- `pageIndex` — индекс книги, с которой начинается список;
- `maxResults` — количество результатов в запросе.

Всего данный запрос принимает около 10 параметров. Как видим, чтобы использовать пагинацию при запросе, нам необходимо изменять начальный индекс `pageIndex`. К тому же поиск по темам требует манипуляций с адресной строкой. Чтобы упростить следующий запрос, создадим файл books.ts в папке api, а также следующую функцию:

```html
        'books.ts'

        **import** { **NextApiRequest**, **NextApiResponse** } **from** 'next';

        **export** **default** **async** **function** **handler**(req: NextApiRequest, res: NextApiResponse) { ... }
```

Аргумент `req` — это объект запроса, у которого есть параметр `query`. В отличие от предыдущего запроса, в нашем будет всего лишь два параметра: `subject` и `page`. Запрос будет выглядеть так:

```html
GET localhost:3000/api/books?subject=Fiction&page=1
```

В функции `handler` обработаем параметры и выполним запрос:

```html
        **const** { subject, page } = req.query;

        **const** gbooksReqParams = **new** **URLSearchParams**();
        gbooksReqParams.**set**('q', `Subject:${subject}`);
        ...
        
        **const** res = **await** **fetch**(`https://www.googleapis.com/books/v1/volumes?${gbooksReqParams.toString()}`)
        
        **const** booksData = **await** res.**json**();
```

Затем нам необходимо дать ответ со статусом 200:

```html
        res.status(200).send({
            data: booksData,
        })
```

Если в запросе мы не указали параметр `subject`, то API может ответить 400 статусом и выдать ошибку:

```html
        **if** (!req.query.subject) {
            res.status(400).send({
                error: true,
                message: 'No subject in query params'
            })
        }
```

После создания API для получения списка книг создадим API авторизации в файле api/auth.ts. **Необходимо создать следующий функционал:**

- Валидация полей. Поле E-mail должно принимать только электронную почту. Пароль должен состоять из не менее чем 6-9 символов.
- Если данные правильные, то ответ должен вернуть данные об успешной авторизации.
- Если данные неправильные, сервер отвечает 400 статусом.
- Эндпоинт обрабатывает только POST-запросы.

```html
        export **default** async **function** **handler**(req, res) {
        **if** (req.status !== 'POST') {
            res.**status**(405).**send**({ error: true, message: 'Only POST' })
        }

        **const** { email, password } = req.body;
        // Ваша функция для валидации
        **const** validatedInfo = **validate**(email, password);

        **if** (validatedInfo.error) {
            res.**status**(400).**send**({ error: true, message: 'Email or password are incorrect' });
        } **else** {
            res.**status**(200).**send**({ success: true, token: 'testToken' });
        }
    }
```

Этого API будет достаточно, чтобы сымитировать авторизацию в приложении. Теперь вы можете создать собственный BFF в папке /api, который позволит получать список книг по темам постранично, а также авторизовывать пользователя.

Когда вы проектируете API, не забывайте использовать правильные HTTP-статусы, методы, а также валидировать приходящие данные.

## **ЗАДАНИЕ**

**Вам необходимо спроектировать BFF для следующих запросов:**

- получение списка книг с помощью Google Books API;
- фейковая авторизация с получением токена и валидацией данных.

Наша цель — сделать фильтрацию книг на главной странице, корзину и авторизацию. Для этого мы будем использовать самую популярную библиотеку для управления состоянием — Redux Toolkit.

Использование Redux Toolkit в проекте на Next.js очень похоже на использование его же в классическом проекте на React.

Для начала установим необходимые библиотеки:

```html
npm install @reduxjs/toolkit react-redux
```

Как и в стандартном проекте, в задании нам необходимо создать хранилище с помощью метода `configureStore` и обернуть весь проект в `Provider`.

```html
    '_app.tsx'

    **import** { **Provider** } **from** 'react-redux';
    **import** { configureStore } **from** '@reduxjs/toolkit';
    **import** { filterSlice } **from** './store/filters';
    
    **const** store = **configureStore**({
        reducer: {
            filterSlice,
        }
    })
    
    **export** **default** **function** **App**({ Component, pageProps }) {
        **return** (
            <**Provider** store={store}>
                <**Layout**>
                    <**Component** {...pageProps} />
                </**Layout**>
            </**Provider**>
        )
    }
```

Для работы с данными хранилища и вызова экшенов вы можете использовать хуки `useSelector` и `useDispatch`, как в обычном приложении.

Так как проект не подразумевает использование бэкенда для авторизации и сохранения корзины, мы будем сохранять корзину, фильтры и информацию о пользователе в `localStorage` с помощью библиотеки Redux Persist.

Для начала установим саму библиотеку:

        `npm install redux-persist @types/redux-persist`

Далее нам необходимо **подключить её в проект следующим образом**:

1. Создаём конфигурацию для Redux Persist:
    
    ```html
    // <reference types="redux-persist" />
    **import** storage **from** 'redux-persist/lib/storage';
    
    **const** persistConfig = {
        key: 'root' //Название ключа в localStorage
    	storage,
    }
    ```
    
    Если вы используете TypeScript в проекте, то не забудьте добавить строку `<reference types=”redux-persist” />`.
    
2. Создаём корневой редьюсер с помощью `combineReducers` и оборачиваем его в `persistReducer`.
    
    ```html
    **import** { combineReducers } **from** '@reduxjs/toolkit';
    **import** { persistReducer } **from** 'redux-persist';
    
    **const** rootReducer = **combineReducers**({ slice1, slice2, ...})
    
    **const** persistedReducer = **persistReducer**(persistConfig, rootReducer);
    ```
    
3. Передаём новый редьюсер в `configureStore` и экспортируем так называемый `persistor`:
    
    ```html
    **import** { persistStore } **from** 'redux-persist';
    
    **const** store = **configureStore**({ reducer: persistedReducer });
    
    **export** **const** persistor = **persistStore**(store);
    
    **export** **default** store;
    ```
    
4. В файл _app.tsx добавим новый компонент `PersistGate`:
    
    ```html
    **import** { **PersistGate** } **from** 'redux-persistor/integration/react';
    **import** store, { persistor } **from** './store';
    
    **export** **default** **function** **App**({ Component, pageProps }) {
        **return** (
            <**Provider** store={store}>
                <**PersistGate** loading={null} persistor={persistor}>
                    <**Component** {...pageProps} />
                </**PersistGate**>
            </**Provider**>
        )
    }
    ```
    

Пропс `loading` отвечает за отображение заглушки, если загрузка нашего стора из `localStorage` занимает слишком много времени.

После подключения у вас должна появиться следующая ошибка:

Она связана с сериализацией данных в хранилище. Чтобы избавиться от ошибки, нам необходимо внести изменения в конфигурацию стора в `configureStore`.

```html
**const** store = **configureStore**({
    reducer: persisterReducer,
    middleware: (getDefaultMiddleware) => **getDefaultMiddleware**({
        serializeableCheck: false,
    })
})
```

Чтобы не отключать проверку сериализуемых данных полностью, можно импортировать список экшенов из библиотеки Redux Persist, для которых необходимо отключить проверку:

```html
import {
    FLUSH,
    REHYDRATE,
    PAUSE,
    PERSIST,
    PURGE,
    REGISTER,
} **from** 'redux-persist';

**const** store = **configureStore**({
    reducer: persisterReducer,
    middleware: (getDefaultMiddleware) => **getDefaultMiddleware**({
        serializeableCheck: {
            ignoredActions: [FLUSH, REHYDRATE, PAUSE, PERSIST < PURGE, REGISTER]
        },
    })
})
```

Теперь мы можем увидеть наш сохранённый стор в `localStorage`:

## **ЗАДАНИЕ**

Добавьте Redux Toolkit и Redux Persist в проект. **Вы будете использовать хранилище для:**

- Сохранения книг в корзине и информации о них. Например, названия, автора, цены и количества;
- Текущего фильтра поиска на главной странице;
- Авторизации пользователя — приложение обращается к API, достаёт данные о пользователе и сохраняет.

Недавно в Next.js появились полезные утилиты для оптимизации работы со шрифтами и изображениями.

`next/font` предназначена для упрощения подключения шрифтов, в том числе тех, что поставляются Google.

В макете используется шрифт Montserrat, который можно подключить следующим образом:

```html
**import** { **Montserrat** } **from** 'next/font/google';

    **const** font = **Montserrat**({
        weight: ["400"],
        subsets: ["latin", "cyrillic"],
    })
    
    **export** **default** **function** **Layout**() {
        **return** <**div** className={font.className}>...</**div**>
    }
```

Параметр `weight` отвечает за вес шрифта и принимает массив значений от 100 до 900. Параметр `subsets` отвечает за подключение подмножеств шрифта. Например, латиницу, кириллицу и т.д.

Теперь мы подключили в проект требуемый шрифт без необходимости подключать его через теги в `head`.

Кроме того, для оптимизации загружаемых изображений можно использовать встроенный компонент `Image`. Он поддерживает ленивую загрузку при последовательном скролле страницы и позволяет использовать заглушку при загрузке изображения.

```html
**import** **Image** **from** 'next/image';

    **export** **default** **function** **SomeComponent**({ src }) {
        **return** (
            ...
    <**Image** src = { src } alt = "Изображение" width = { 300} height = { 400} />
        ...
        )
    }
```

Параметры `src`, `alt`, `width` и `height` являются обязательными.

Если вы используете изображения с других доменов (в нашем случае это изображения из API Google Books), то в таком случае необходимо внести изменения в конфигурацию проекта.

Добавим наш домен в next.config.js:

```html
'next.config.js'

    **const** nextConfig = {
        ...
        images: {
            remotePatterns: ['books.google.com'],
        }
    }
    
    // или
    
    **const** patterns = [{ protocol: 'http', hostname: 'books.google.com' }]
    
    **const** nextConfig = {
        images: {
            remotePatterns: patterns,
        }
    }
```

### **Полезные ссылки:**

- [next/font — документация](https://nextjs.org/docs/api-reference/next/font)
- [next/image — документация](https://nextjs.org/docs/api-reference/next/image)

## **ЗАДАНИЕ**

**Вам необходимо использовать компонент `Image` из `next/image` в:**

- Слайдере на главной странице;
- Обложке книги на главной странице;
- Обложке книги в корзине;
- Статичном изображении в профиле.

Также подключите шрифт Montserrat в приложение с помощью `next/font`.

У HTML-страниц должны быть метаданные, которые содержат основную информацию об этой странице: название, описание, кодировку и т.д. Эти данные индексируются поисковиками. Компонент `Head` позволяет нам легко добавлять метаданные на любую страницу нашего проекта.

Добавить тег на страницу можно так:

```html
**import** **Head** **from** 'next/head';

    **export** **default** **function** **SomePage**() {
        **return** (
            <>
                <**Head**>
                    <**title**>Название вашей страницы</**title**>
                    <**meta** name="description" content="Описание вашей страницы" />
                    <**meta** name="author" content="Ваше имя" />
                </**Head**>
                ...
            </>
        )
    }
```

Теги влияют на индексацию приложения в поисковике. Страницы с названием и описанием будет проще найти при поиске. Также они будут выше по рейтингу.

Чтобы протестировать приложение на оптимизацию при поиске, можно воспользоваться вкладкой Lighthouse. Она доступна в большинстве версий Chrome, а также в Microsoft Edge на Chromium.

Перед тем, как создать отчет, выполним сборку проекта с помощью команды:

        `npm run build`

Она создаст оптимизированный билд и сгенерирует несколько HTML-страниц. Вы можете открыть любую страницу и создать отчёт в браузере. Для этого нужно нажать на кнопку «Анализ загрузки страницы». Анализ займёт примерно 10-20 секунд.

**Всего есть 4 параметра:**

- **Производительность** — скорость первоначальной загрузки страницы. Зависит от количества загружаемого HTML, CSS и JavaScript-кода.
- **Специальные возможности** — показатель доступности страницы для людей с ограниченными возможностями.
- **Рекомендации** — параметр, который показывает ошибки правильного использования API браузера и правильность использования современных стандартов веб-разработки.
- **Уровень SEO-оптимизации**, а также рекомендации по дальнейшему улучшению.

### **Важно!**

Высокие значения в Chrome Lighthouse не являются гарантом качества вашего приложения. Это всего лишь метрики, которые могут использоваться для его улучшения.

## **ЗАДАНИЕ**

Проведите аудит настольной версии книжного магазина с помощью Lighthouse. Все показатели рейтинга должны набрать минимум 50 очков.

**Напоминание:**

- Не забывайте проводить аудит только на продакшен-версии приложения. Версия для разработки может показывать некорректные значения.
- Не забывайте пользоваться встроенными компонентами и возможностями Next.js, чтобы повысить рейтинг.
- Не забывайте про основы доступности — теги `alt` для изображений и семантическую вёрстку.

Т**еперь мы задеплоим готовое приложение. Для того, чтобы это сделать, нужно:**

1. Зарегистрироваться на сайте [vercel.com](https://vercel.com/login).
2. Импортировать Git-репозиторий на GitHub, в котором расположено ваше приложение.
3. Настроить конфигурацию проекта. Скорее всего вам не придётся ничего менять, так как Vercel является разработчиком фреймворка Next.js и автоматически настраивает для него конфигурацию.
4. Нажать на кнопку Deploy и дождаться сборки и деплоя проекта.

В форму для сдачи домашнего задания ниже приложите ссылку на **Git-репозиторий** и ссылку на **задеплоеное приложение** на Vercel.

Не забудьте убедиться, что репозиторий настроен как публичный, иначе ментор не сможет проверить ваш код.